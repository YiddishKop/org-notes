<p>Danny Hillis&rsquo; seminal work <a href="http://www.amazon.com/gp/product/0262580977/ref=as_li_tf_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0262580977&amp;linkCode=as2&amp;tag=blog0cbb-20">The Connection Machine</a> introduced, among many other things, the concept of &ldquo;beta reduction&rdquo; on vectors<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> (I dub this &ldquo;Hillis beta reduction&rdquo; so as not to confuse the term with traditional <a href="http://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction">beta reduction</a> in the lambda calculus). I found this particular idea fascinating and still applicable today, if only as a quick thought experiment.</p>

<p>Hillis asserted that the everyday <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">fold / reduce routines</a> that we have all come to know and love are merely a subset of a larger scheme of operations that can be performed on ordered data structures. The overarching process is named the &ldquo;beta function,&rdquo; and accepts one function and two vectors as arguments. The result of this function is the combination of the two vectors into a map, using the first vector to form the map&rsquo;s values and the second vector to form the map&rsquo;s keys. When duplicate keys are found, the provided function is used to &ldquo;combine&rdquo; the corresponding values. It&rsquo;s an interesting process that&rsquo;s much easier to understand given an example:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">beta</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">X</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="n">Z</span><span class="p">))</span><span class="w">  </span><span class="err">;</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">X</span><span class="w"> </span><span class="mi">1</span><span class="n">,</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="mi">7</span><span class="p">}</span></code></pre></figure>

<p>Using the positions of each element to match keys and values of the map to be formed, the beta function pulls together data like a zip function. When the duplicate key <code class="highlighter-rouge">Z</code> is encountered twice, the two values are combined using the <code class="highlighter-rouge">+</code> function we provided, and the final value corresponding to the key <code class="highlighter-rouge">Z</code> in the map is <code class="highlighter-rouge">(+ 2 5)</code>, or <code class="highlighter-rouge">7</code>.</p>

<p>What is traditional list folding, then? Why, it&rsquo;s just beta reduction with a certain constant second argument:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">beta</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">  </span><span class="err">;</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="mi">8</span><span class="p">}</span></code></pre></figure>

<p>When we provide the beta function with the same key for every value (<code class="highlighter-rouge">1</code>, in this case), all values are combined to the same key using the provided function. This is reduction in a different form!<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup></p>

<p>Below is an implementation of Hillis&rsquo; beta function in Clojure. I included a shorthand form of the function in which a two-argument call will give the same result as a call to <code class="highlighter-rouge">reduce</code>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nf">beta</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="nf">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">  </span><span class="err">;</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="mi">8</span></code></pre></figure>

<p>Feel free to play around!</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">beta</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="w"> </span><span class="n">c1</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">beta</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">f</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="n">c2</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">acc</span><span class="w"> </span><span class="p">{}</span><span class="w">
            </span><span class="n">e1</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w">
            </span><span class="n">e2</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">c2</span><span class="p">)</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">c2</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">e1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">e2</span><span class="p">))</span><span class="w">
         </span><span class="n">acc</span><span class="w">
         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">new-val</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w">
                         </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">e2</span><span class="p">)</span><span class="w"> </span><span class="n">e1</span><span class="p">)</span><span class="w">
                         </span><span class="n">e1</span><span class="p">)]</span><span class="w">
           </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="n">new-val</span><span class="p">)</span><span class="w">
                  </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">c1</span><span class="p">)</span><span class="w">
                  </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">c2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">c2</span><span class="p">)))))))</span></code></pre></figure>

<p><img src="http://www.assoc-amazon.com/e/ir?t=blog0cbb-20&amp;l=as2&amp;o=1&amp;a=0262580977" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>For simplicity&rsquo;s sake, I deliberately ripped out Hillis&rsquo; concept of beta reduction from its containing system of parallel processing with xectors. References to this particular domain have been shamelessly replaced with Clojure-specific terms.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>You may notice that this alternate fold returns <code class="highlighter-rouge"><span class="p">{</span><span class="err">1</span><span class="w"> </span><span class="err">8</span><span class="p">}</span></code> rather than a simple <code class="highlighter-rouge">8</code>. This is due to my somewhat-haphazard readaptation of Hillis&rsquo; concept for Clojure: the <code class="highlighter-rouge"><span class="p">{</span><span class="err">1</span><span class="w"> </span><span class="err">8</span><span class="p">}</span></code> that is returned is technically correct within Hillis&rsquo; system of xectors, but is not convenient for those of us living in a von Neumann world. I experimented in using a xector monad as a sort of shim to better integrate beta-reduction into Clojure, but did not develop it far enough to make it merit more than a mention in a footnote.&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div><img src="http://feeds.feedburner.com/~r/foldl/rss/~4/Xf47ekFuRSI" height="1" width="1" alt=""/>
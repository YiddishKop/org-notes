<p>I decided to rewrite my <a href="/2012/hillis-beta-reduction-in-clojure">Hillis Î²-reduction routine</a> in Haskell. I
was very pleased to find that the rewrite yielded code much more concise
and less &ldquo;hacky&rdquo; than the original Clojure algorithm.<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">module</span> <span class="nn">Beta</span> <span class="p">(</span><span class="nf">beta</span><span class="p">)</span>
<span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Map</span> <span class="p">(</span><span class="kt">Map</span><span class="p">,</span> <span class="nf">alter</span><span class="p">,</span> <span class="nf">empty</span><span class="p">)</span>

<span class="c1">-- Used to insert or merge map values. Partially apply this function</span>
<span class="c1">-- with a merge function and an initial value, then use it in</span>
<span class="c1">-- `Data.Map.alter`.</span>
<span class="n">alterer</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">alterer</span> <span class="kr">_</span> <span class="n">v</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">v</span>
<span class="n">alterer</span> <span class="n">f</span> <span class="n">v</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">v</span> <span class="n">x</span><span class="p">)</span>

<span class="c1">-- beta-reduce a list of keys and values with a given merge function.</span>
<span class="n">beta</span> <span class="o">::</span> <span class="kt">Ord</span> <span class="n">k</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span><span class="p">)</span>
<span class="n">beta</span> <span class="n">f</span> <span class="n">keys</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">beta'</span> <span class="n">empty</span> <span class="n">f</span> <span class="n">keys</span> <span class="n">vals</span>

<span class="c1">-- Internal recursive function.</span>
<span class="n">beta'</span> <span class="o">::</span> <span class="kt">Ord</span> <span class="n">k</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span><span class="p">)</span>
<span class="n">beta'</span> <span class="n">map</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="n">map</span>
<span class="n">beta'</span> <span class="n">map</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">map</span>
<span class="n">beta'</span> <span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">k</span><span class="o">:</span><span class="n">ks</span><span class="p">)</span> <span class="p">(</span><span class="n">v</span><span class="o">:</span><span class="n">vs</span><span class="p">)</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">map'</span> <span class="o">=</span> <span class="n">alter</span> <span class="p">(</span><span class="n">alterer</span> <span class="n">f</span> <span class="n">v</span><span class="p">)</span> <span class="n">k</span> <span class="n">map</span>
                            <span class="kr">in</span> <span class="n">beta'</span> <span class="n">map'</span> <span class="n">f</span> <span class="n">ks</span> <span class="n">vs</span></code></pre></figure>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html"><code class="highlighter-rouge">Data.Map</code></a> turned out to be a lifesaver!&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div><img src="http://feeds.feedburner.com/~r/foldl/rss/~4/1Mi-PlfYQj4" height="1" width="1" alt=""/>
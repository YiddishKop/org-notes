
            

            <p>I want to build a ring of symbols in my init.el for the purpose of rotating themes. I could do it like this:</p>

<pre><code>(let* ((themes '(doom-one zenburn leuven))
       (ring (make-ring (length themes))))
  (mapc (lambda (x) (ring-insert ring x))
        themes)
  (setq my-theme-ring ring))
</code></pre>

<p>which results in the following data-structure</p>

<pre><code>(0 3 . [doom-one zenburn leuven])
</code></pre>

<p>Or, I could build it more directly:</p>

<pre><code>(let* ((vector [doom-one zenburn leuven])
       (ring `(0 ,(length vector) . ,vector)))
  (setq my-theme-ring ring)
</code></pre>

<p>The first approach goes through the ring.el public API and makes no assumptions about its implementation.</p>

<p>The second approach does less work, but could break if ring.el changes its implementation.</p>

<p>I <em>think</em> I can use <em>eval-when-compile</em> to get the best of both worlds:</p>

<pre><code>(setq my-theme-ring
      (eval-when-compile
        (let* ((themes '(doom-one zenburn leuven))
               (ring (make-ring (length themes))))
          (mapc (lambda (x) (ring-insert ring x))
                themes)
          ring)))
</code></pre>

<p>Or maybe even:</p>

<pre><code>(eval-when-compile
  (let* ((themes '(doom-one zenburn leuven))
         (ring (make-ring (length themes))))
    (mapc (lambda (x) (ring-insert ring x))
          themes)
    (setq my-theme-ring ring)))
</code></pre>

<p>When I compile my init file, it will iterate over the themes and add them one-by-one to the ring. When I start Emacs and load my already compiled init file, however, it will just read the already populated ring that resulted during compilation.</p>

<p>Is that right? And if so, can I nest the <em>setq</em> call within the <em>eval-when-compile</em> body too, as I've done in the last code snippet, or can I only use the compiled result for the value it returns?</p>

        
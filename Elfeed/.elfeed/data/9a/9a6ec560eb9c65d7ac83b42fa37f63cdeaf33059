<p>
As <a href="/clj-refactor-unleash-your-clojure-wizard.html">you may remember</a>, one of the commands I like the most from the <code>clj-refactor</code>
package are the ones that thread and unwind Clojure code forms for you. Now that
Emacs is also getting <a href="/new-in-emacs-25-1-more-flow-control-macros.html">built-in threading macros</a>, I figured the best way to give
them a fair chance in life is to also make them pretty convenient to use.
</p>

<p>
The point here is that you can place point before a paren, invoke a command, and
a regular code form gets transformed into a threading macro, or vice-versa. See
the <a href="/new-in-emacs-25-1-more-flow-control-macros.html">linked post</a> for what that means. Instead of writing whole new commands for
that, I had a fun time just hacking <code>clj-refactor</code> commands to work on
<code>thread-first/last</code>.
</p>

<p>
It should go without saying, you need <a href="https://github.com/clojure-emacs/clj-refactor.el#readme">clj-refactor</a> installed for this to work. 
</p>
<figure class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">define-key</span> <span class="nv">emacs-lisp-mode-map</span> <span class="s">"\C-ctf"</span>
  <span class="nf">#'</span><span class="nv">endless/elisp-thread-first</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="nv">emacs-lisp-mode-map</span> <span class="s">"\C-ctl"</span>
  <span class="nf">#'</span><span class="nv">endless/elisp-thread-last</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="nv">emacs-lisp-mode-map</span> <span class="s">"\C-ctu"</span>
  <span class="nf">#'</span><span class="nv">endless/elisp-unwind</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="nv">emacs-lisp-mode-map</span> <span class="s">"\C-cta"</span>
  <span class="nf">#'</span><span class="nv">endless/elisp-unwind-all</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">endless/elisp-thread-last</span> <span class="p">()</span>
  <span class="s">"Turn the form at point into a `thread-last' form."</span>
  <span class="p">(</span><span class="nv">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">cljr-thread-last-all</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">save-excursion</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">search-backward</span> <span class="s">"-&gt;&gt;"</span> <span class="no">nil</span> <span class="ss">'noerror</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">replace-match</span> <span class="s">"thread-last"</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">endless/elisp-thread-first</span> <span class="p">()</span>
  <span class="s">"Turn the form at point into a `thread-first' form."</span>
  <span class="p">(</span><span class="nv">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">cljr-thread-first-all</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">save-excursion</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">search-backward</span> <span class="s">"-&gt;"</span> <span class="no">nil</span> <span class="ss">'noerror</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">replace-match</span> <span class="s">"thread-first"</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">endless/elisp-unwind</span> <span class="p">()</span>
  <span class="s">"Unwind thread at point or above point by one level.
Return nil if there are no more levels to unwind."</span>
  <span class="p">(</span><span class="nv">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">p</span> <span class="p">(</span><span class="nv">point</span><span class="p">)))</span>
    <span class="c1">;; Find a thread above.</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">save-excursion</span>
            <span class="p">(</span><span class="nv">forward-sexp</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">search-backward-regexp</span> <span class="s">"\\_&lt;thread-\\(first\\|last\\)\\_&gt;"</span> <span class="no">nil</span> <span class="ss">'noerror</span><span class="p">)</span>
                 <span class="c1">;; Ensure that it contains the original point.</span>
                 <span class="p">(</span><span class="nv">save-match-data</span> <span class="p">(</span><span class="nv">forward-char</span> <span class="mi">-1</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nv">forward-sexp</span> <span class="mi">1</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">point</span><span class="p">)</span> <span class="nv">p</span><span class="p">))))</span>
      <span class="p">(</span><span class="nv">replace-match</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=</span> <span class="p">(</span><span class="nv">match-string</span> <span class="mi">1</span><span class="p">)</span> <span class="s">"first"</span><span class="p">)</span>
                         <span class="s">"-&gt;"</span> <span class="s">"-&gt;&gt;"</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">thread-beginnig</span> <span class="p">(</span><span class="nv">match-beginning</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">prog1</span> <span class="p">(</span><span class="nv">cljr-unwind</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">save-excursion</span>
            <span class="p">(</span><span class="nv">goto-char</span> <span class="nv">thread-beginnig</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">looking-at</span> <span class="s">"\\_&lt;-&gt;&gt;?\\_&gt;"</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">replace-match</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">string=</span> <span class="p">(</span><span class="nv">match-string</span> <span class="mi">0</span><span class="p">)</span> <span class="s">"-&gt;"</span><span class="p">)</span>
                                 <span class="s">"thread-first"</span> <span class="s">"thread-last"</span><span class="p">)))))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">endless/elisp-unwind-all</span> <span class="p">()</span>
  <span class="s">"Fully unwind thread at point or above point."</span>
  <span class="p">(</span><span class="nv">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">while</span> <span class="p">(</span><span class="nv">endless/elisp-unwind</span><span class="p">)))</span></code></pre></figure>

<p>
Maybe just writing it from scratch would have made for shorter code (it would
certainly be more robust). But such is life. I try not to dwell too much on
quick hacks.</p>

   <p><a href="http://endlessparentheses.com/commands-to-thread-and-unwind-code-in-emacs-lisp.html?source=rss#disqus_thread">Comment on this.</a></p>
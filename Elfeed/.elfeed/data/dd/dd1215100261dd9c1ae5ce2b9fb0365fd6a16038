<div class="paragraph">This post originally appeared on the <a href="http://julialang.org/blog/2017/03/piday" target="_blank">Julialang.org blog</a>.</div><div><div id="377822578145737142" align="left" class="wcustomhtml"><div id="site" class="site"><div class="title"><a href="http://www.numfocus.org/"><!-- blue dot --><!-- red dot --><!-- green dot --><!-- purple dot --><!-- "j" --><!-- "u" --><!-- "l" --><!-- "i" --><!-- "a" --></a></div><div id="blogpost"><h1>Some fun with &pi; in Julia</h1><p class="metadata"><span class="timestamp">14 Mar 2017</span> &nbsp;|&nbsp; <span class="author">Simon Byrne, Luis Benet and David Sanders</span></p><p><em>This post is available as a Jupyter notebook <a href="https://github.com/simonbyrne/Pi.jl/blob/master/pi.ipynb">here</a></em></p><h2 id="&pi;-in-julia">&pi; in Julia</h2><p><em>(<a href="https://github.com/simonbyrne">Simon Byrne</a>)</em></p><p>Like most technical languages, Julia provides a variable constant for &pi;. However Julia&rsquo;s handling is a bit special.</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="nb">pi</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>&pi; = 3.1415926535897...</code></pre></div><p>It can also be accessed via the unicode symbol (you can get it at the REPL or in a notebook via the TeX completion <code class="highlighter-rouge">\pi</code> followed by a tab)</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">&pi;</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>&pi; = 3.1415926535897...</code></pre></div><p>You&rsquo;ll notice that it doesn&rsquo;t print like an ordinary floating point number: that&rsquo;s because it isn&rsquo;t one.</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="nb">typeof</span><span class="x">(</span><span class="nb">pi</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>Irrational{:&pi;}</code></pre></div><p>&pi; and a few other irrational constants are instead stored as special <code class="highlighter-rouge">Irrational</code> values, rather than being rounded to <code class="highlighter-rouge">Float64</code>. These act like ordinary numeric values, except that they can are converted automatically to any floating point type without any intermediate rounding:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="nb">pi</span> <span class="c"># integers are promoted to Float64 by default</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>4.141592653589793</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="kt">Float32</span><span class="x">(</span><span class="mi">1</span><span class="x">)</span> <span class="o">+</span> <span class="nb">pi</span> <span class="c"># Float32</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>4.141593f0</code></pre></div><p>This is particularly useful for use with arbitrary-precision <code class="highlighter-rouge">BigFloat</code>s, as &pi; can be evaluated to full precision (rather than be truncated to <code class="highlighter-rouge">Float64</code> and converted back).</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="kt">BigFloat</span><span class="x">(</span><span class="mi">1</span><span class="x">)</span> <span class="o">+</span> <span class="nb">pi</span> <span class="c"># 256 bits by default</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>4.141592653589793238462643383279502884197169399375105820974944592307816406286198</code></pre></div><p>If &pi; were stored as a <code class="highlighter-rouge">Float64</code>, we would instead get</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="kt">BigFloat</span><span class="x">(</span><span class="mi">1</span><span class="x">)</span> <span class="o">+</span> <span class="kt">Float64</span><span class="x">(</span><span class="nb">pi</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>4.141592653589793115997963468544185161590576171875000000000000000000000000000000</code></pre></div><p>In fact <code class="highlighter-rouge">BigFloat</code> (which uses the <a href="http://www.mpfr.org">MPFR</a> library) will compute &pi; on demand to the current precision, which is set via <code class="highlighter-rouge">setprecision</code>. This provides an easy way to get its digits:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="c"># to 1024 bits</span><span class="n">setprecision</span><span class="x">(</span><span class="kt">BigFloat</span><span class="x">,</span> <span class="mi">1024</span><span class="x">)</span> <span class="n">do</span>     <span class="kt">BigFloat</span><span class="x">(</span><span class="nb">pi</span><span class="x">)</span><span class="k">end</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724586997</code></pre></div><p>The last few printed digits may be incorrect due to the conversion from the internal binary format of <code class="highlighter-rouge">BigFloat</code> to the decimal representation used for printing. This is just a presentation issue, however &ndash; the internal binary representation is correctly rounded to the last bit.</p><p>Another neat property of <code class="highlighter-rouge">Irrational</code>s is that inequalities are correct:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="kt">Float64</span><span class="x">(</span><span class="nb">pi</span><span class="x">)</span> <span class="o">&lt;</span> <span class="nb">pi</span> <span class="o">&lt;</span> <span class="n">nextfloat</span><span class="x">(</span><span class="kt">Float64</span><span class="x">(</span><span class="nb">pi</span><span class="x">))</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>true</code></pre></div><h2 id="&pi;-via-inline-assembly-instructions">&pi; via inline assembly instructions</h2><p><em>(<a href="https://github.com/simonbyrne">Simon Byrne</a>)</em></p><p>Julia provides a very low-level <code class="highlighter-rouge">llvmcall</code> interface, which allows the user to directly write <a href="http://llvm.org/docs/LangRef.html">LLVM intermediate representation</a>, including the use of inline assembly. The following snippet calls the <code class="highlighter-rouge">fldpi</code> instruction (&ldquo;<strong>f</strong>loating point <strong>l</strong>oa<strong>d</strong> <strong>pi</strong>&rdquo;) which loads the constant &pi; onto the floating point register stack (this works only on x86 and x86_64 architectures)</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> asm_pi</span><span class="x">()</span>    <span class="n">Base</span><span class="o">.</span><span class="n">llvmcall</span><span class="x">(</span>    <span class="s">""" %pi = call double asm "</span><span class="n">fldpi</span><span class="s">", "</span><span class="o">=</span><span class="x">{</span><span class="n">st</span><span class="x">}</span><span class="s">"()        ret double %pi"""</span><span class="x">,</span>     <span class="kt">Float64</span><span class="x">,</span> <span class="n">Tuple</span><span class="x">{})</span><span class="k">end</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>asm_pi (generic function with 1 method)</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">asm_pi</span><span class="x">()</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>3.141592653589793</code></pre></div><p>We can look at the actual resulting code that is generated:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="nd">@code_native</span> <span class="n">asm_pi</span><span class="x">()</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>    .section        __TEXT,__text,regular,pure_instructionsFilename: In[10]        pushq   %rbp        movq    %rsp, %rbpSource line: 2        fldpi        fstpl   -8(%rbp)        movsd   -8(%rbp), %xmm0         ## xmm0 = mem[0],zero        popq    %rbp        retq</code></pre></div><p>If you&rsquo;re wondering what the rest of these instructions are doing:</p><ol><li>the <code class="highlighter-rouge">pushq</code> and <code class="highlighter-rouge">movq</code> adds to the <a href="https://en.wikipedia.org/wiki/Call_stack">call stack frame</a>.</li><li><code class="highlighter-rouge">fldpi</code> pushes &pi; to the x87 floating point register stack<ul><li>x87 is the older legacy floating point instruction set dating back to the original <a href="https://en.wikipedia.org/wiki/Intel_8087">Intel 8087 coprocessor</a>.</li></ul></li><li><code class="highlighter-rouge">fstpl</code> and <code class="highlighter-rouge">movsd</code> moves the value to the SSE floating point register <code class="highlighter-rouge">xmm0</code><ul><li>Julia, like most modern software, uses the newer SSE instruction set for its floating point operations. This also allows us to take advantage of things like <a href="https://en.wikipedia.org/wiki/SIMD">SIMD operations</a>.</li></ul></li><li><code class="highlighter-rouge">popq</code> and <code class="highlighter-rouge">retq</code> pops the call stack frame.</li></ol><h2 id="&pi;-using-a-taylor-series-expansions">&pi; using a Taylor series expansions</h2><p><em>(<a href="https://github.com/lbenet">Luis Benet</a>, Instituto de Ciencias F&iacute;sicas, Universidad Nacional Aut&oacute;noma de M&eacute;xico (UNAM))</em></p><p>This will demonstrate how to evaluate &pi; using various Taylor series expansions via the <a href="https://github.com/JuliaDiff/TaylorSeries.jl">TaylorSeries.jl</a> package.</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">using</span> <span class="n">TaylorSeries</span></code></pre></div><h3 id="madhavas-formula">Madhava&rsquo;s formula</h3><p>One of the standard trigonmetric identities is </p><p>Therefore, by taking the Taylor expansion of $ 6 \arctan(x) $ around 0 we may obtain the value of $\pi$, by evaluating it at $1/\sqrt{3}$, a value which is within the radius of convergence.</p><p>We obtain the Taylor series of order 37th, using <code class="highlighter-rouge">BigFloat</code>s:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">series1</span> <span class="o">=</span> <span class="mi">6</span><span class="n">atan</span><span class="x">(</span> <span class="n">Taylor1</span><span class="x">(</span><span class="kt">BigFloat</span><span class="x">,</span> <span class="mi">37</span><span class="x">)</span> <span class="x">)</span><span class="nb">convert</span><span class="x">(</span><span class="n">Taylor1</span><span class="x">{</span><span class="n">Rational</span><span class="x">{</span><span class="kt">BigInt</span><span class="x">}},</span><span class="n">series1</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code> 6//1 t - 2//1 t&sup3; + 6//5 t&#8309; - 6//7 t&#8311; + 2//3 t&#8313; - 6//11 t&sup1;&sup1; + 6//13 t&sup1;&sup3; - 2//5 t&sup1;&#8309; + 6//17 t&sup1;&#8311; - 6//19 t&sup1;&#8313; + 2//7 t&sup2;&sup1; - 6//23 t&sup2;&sup3; + 6//25 t&sup2;&#8309; - 2//9 t&sup2;&#8311; + 6//29 t&sup2;&#8313; - 6//31 t&sup3;&sup1; + 2//11 t&sup3;&sup3; - 6//35 t&sup3;&#8309; + 6//37 t&sup3;&#8311; + ?(t&sup3;&#8312;)</code></pre></div><p>Note that the series above has only odd powers, so we will be using in this case 18 coefficients.</p><p>Evaluating that expression in $1/\sqrt{3}$ we get</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">pi_approx1</span> <span class="o">=</span> <span class="n">evaluate</span><span class="x">(</span><span class="n">series1</span><span class="x">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="x">(</span><span class="n">big</span><span class="x">(</span><span class="mi">3</span><span class="x">)))</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>3.141592653647826046431202390582141253830948237428790668441592864548346569098516</code></pre></div><p>Then, the 37th order Taylor expansion yields a value which differs from $\pi$ in:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">abs</span><span class="x">(</span><span class="nb">pi</span> <span class="o">-</span> <span class="n">pi_approx1</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>5.803280796855900730263836963377883805368484746664827224053016281231814650118929e-11</code></pre></div><p>To obtain more accurate results, we may simply increase the order of the expansion:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">series2</span> <span class="o">=</span> <span class="mi">6</span><span class="n">atan</span><span class="x">(</span> <span class="n">Taylor1</span><span class="x">(</span><span class="kt">BigFloat</span><span class="x">,</span><span class="mi">99</span><span class="x">)</span> <span class="x">)</span> <span class="c"># 49 coefficients of the series</span><span class="n">pi_approx2</span> <span class="o">=</span> <span class="n">evaluate</span><span class="x">(</span><span class="n">series2</span><span class="x">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span><span class="x">(</span><span class="kt">BigInt</span><span class="x">(</span><span class="mi">3</span><span class="x">)))</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>3.141592653589793238462643347272152237127662423839333289949470742535834074912581</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">abs</span><span class="x">(</span><span class="nb">pi</span> <span class="o">-</span> <span class="n">pi_approx2</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>3.600735064706950697553577253102547384977198233137361734413175534929622111373249e-26</code></pre></div><p>This formulation is one of the <a href="https://en.wikipedia.org/wiki/Madhava_series#Another_formula_for_the_circumference_of_a_circle"><em>Madhava</em> or <em>Gregory&ndash;Leibniz series</em></a>:</p><p>\begin{equation} \pi = 6 \sum_{n=0}^{\infty} (-1)^n \frac{(1/\sqrt{3})^{2n+1}}{2n+1}. \end{equation}</p><h3 id="machins-approach">Machin&rsquo;s approach</h3><p>Following the same idea, <a href="https://en.wikipedia.org/wiki/John_Machin#Formula">John Machin</a> derived an algorithm which converges much faster, using the identity</p><p>\begin{equation} \frac{\pi}{4} = 4 \arctan\left(\frac{1}{5}\right) - \arctan\left(\frac{1}{239}\right). \end{equation}</p><p>Following what we did above, using again a 37th Taylor expansion:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">ser</span> <span class="o">=</span> <span class="n">atan</span><span class="x">(</span> <span class="n">Taylor1</span><span class="x">(</span><span class="kt">BigFloat</span><span class="x">,</span> <span class="mi">37</span><span class="x">)</span> <span class="x">)</span><span class="n">pi_approx3</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="x">(</span> <span class="mi">4</span><span class="o">*</span><span class="n">evaluate</span><span class="x">(</span><span class="n">ser</span><span class="x">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">big</span><span class="x">(</span><span class="mi">5</span><span class="x">))</span> <span class="o">-</span> <span class="n">evaluate</span><span class="x">(</span><span class="n">ser</span><span class="x">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">big</span><span class="x">(</span><span class="mi">239</span><span class="x">))</span> <span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>3.141592653589793238462643383496777424642594661632063407072684671069773618535135</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">abs</span><span class="x">(</span><span class="nb">pi</span> <span class="o">-</span> <span class="n">pi_approx3</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>2.17274540445425262256957586097740078761957212248936631045983596428448951876822e-28</code></pre></div><h2 id="finding-guaranteed-bounds-on-&pi;">Finding guaranteed bounds on &pi;</h2><p><em>(<a href="http://sistemas.fciencias.unam.mx/~dsanders/">David P. Sanders</a>, Department of Physics, Faculty of Sciences, National University of Mexico (UNAM)</em>)</p><h3 id="using-standard-floating-point-arithmetic">Using standard floating-point arithmetic</h3><p>We will calculate <em>guaranteed</em> (i.e., <em>validated</em>, or mathematically rigorous) bounds on $\pi$ using just floating-point arithmetic. This requires &ldquo;directed rounding&rdquo;, i.e. the ability to control in which direction floating-point operations are rounded.</p><p>This is based on the book <a href="http://press.princeton.edu/titles/9488.html"><em>Validated Numerics</em></a> (Princeton, 2011) by <a href="http://www2.math.uu.se/~warwick/CAPA/warwick/warwick.html">Warwick Tucker</a>.</p><p>Consider the infinite series</p><p>whose exact value is <a href="http://en.wikipedia.org/wiki/Basel_problem">known</a> to be $S = \frac{\pi^2}{6}$. Thus, if finding guaranteed bounds on $S$ will give guaranteed bounds on $\pi$.</p><p>The idea is to split $S$ up into two parts, $S = S_N + T_N$, where $ S_N := \sum_{n=1}^N \frac{1}{n^2}$ contains the first $N$ terms, and $T_N := S - S_N = \sum_{n=N+1}^\infty \frac{1}{n^2}$ contains the rest (an infinite number of terms).</p><p>We will evalute $S_N$ numerically, and use the following analytical bound for $T_N$:</p><p>.</p><p>This is obtained by approximating the sum in $T_N$ using integrals from below and above:</p><p>$S_N$ may be calculated easily by summing either forwards or backwards:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> forward_sum</span><span class="x">(</span><span class="n">N</span><span class="x">,</span> <span class="n">T</span><span class="o">=</span><span class="kt">Float64</span><span class="x">)</span>    <span class="n">total</span> <span class="o">=</span> <span class="n">zero</span><span class="x">(</span><span class="n">T</span><span class="x">)</span>    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">N</span>        <span class="n">total</span> <span class="o">+=</span> <span class="n">one</span><span class="x">(</span><span class="n">T</span><span class="x">)</span> <span class="o">/</span> <span class="x">(</span><span class="n">i</span><span class="o">^</span><span class="mi">2</span><span class="x">)</span>    <span class="k">end</span>    <span class="n">total</span><span class="k">end</span><span class="k">function</span><span class="nf"> reverse_sum</span><span class="x">(</span><span class="n">N</span><span class="x">,</span> <span class="n">T</span><span class="o">=</span><span class="kt">Float64</span><span class="x">)</span>    <span class="n">total</span> <span class="o">=</span> <span class="n">zero</span><span class="x">(</span><span class="n">T</span><span class="x">)</span>    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">N</span><span class="x">:</span><span class="o">-</span><span class="mi">1</span><span class="x">:</span><span class="mi">1</span>        <span class="n">total</span> <span class="o">+=</span> <span class="n">one</span><span class="x">(</span><span class="n">T</span><span class="x">)</span> <span class="o">/</span> <span class="x">(</span><span class="n">i</span><span class="o">^</span><span class="mi">2</span><span class="x">)</span>    <span class="k">end</span>    <span class="n">total</span><span class="k">end</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>reverse_sum (generic function with 2 methods)</code></pre></div><p>To find <em>rigorous</em> bounds for $S_N$, we use &ldquo;directed rounding&rdquo;, that is, we round downwards for the lower bound and upwards for the upper bound:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="n">lowerbound_S_N</span> <span class="o">=</span>     <span class="n">setrounding</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">RoundDown</span><span class="x">)</span> <span class="n">do</span>        <span class="n">forward_sum</span><span class="x">(</span><span class="n">N</span><span class="x">)</span>    <span class="k">end</span><span class="n">upperbound_S_N</span> <span class="o">=</span>     <span class="n">setrounding</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">RoundUp</span><span class="x">)</span> <span class="n">do</span>        <span class="n">forward_sum</span><span class="x">(</span><span class="n">N</span><span class="x">)</span>    <span class="k">end</span><span class="x">(</span><span class="n">lowerbound_S_N</span><span class="x">,</span> <span class="n">upperbound_S_N</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>(1.6449330667377557,1.644933066959796)</code></pre></div><p>We incorporate the respective bound on $T_N$ to obtain the bounds on $S$, and hence on $\pi$:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="n">lower_&pi;</span> <span class="o">=</span>    <span class="n">setrounding</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">RoundDown</span><span class="x">)</span> <span class="n">do</span>        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">forward_sum</span><span class="x">(</span><span class="n">N</span><span class="x">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="x">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="x">)</span>        <span class="n">sqrt</span><span class="x">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">lower_bound</span><span class="x">)</span>    <span class="k">end</span><span class="n">upper_&pi;</span> <span class="o">=</span>     <span class="n">setrounding</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">RoundUp</span><span class="x">)</span> <span class="n">do</span>        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">forward_sum</span><span class="x">(</span><span class="n">N</span><span class="x">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span>        <span class="n">sqrt</span><span class="x">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">upper_bound</span><span class="x">)</span>    <span class="k">end</span><span class="x">(</span><span class="n">lower_&pi;</span><span class="x">,</span> <span class="n">upper_&pi;</span><span class="x">,</span> <span class="n">lowerbound_S_N</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>(3.1415926534833463,3.1415926536963346,1.6449330667377557)</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">upper_&pi;</span> <span class="o">-</span> <span class="n">lower_&pi;</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>2.1298829366855898e-10</code></pre></div><p>We may check that the true value of $\pi$ is indeed contained in the interval:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">lower_&pi;</span> <span class="o">&lt;</span> <span class="nb">pi</span> <span class="o">&lt;</span> <span class="n">upper_&pi;</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>true</code></pre></div><p>Summing in the opposite direction turns out to give a more accurate answer:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="n">lower_&pi;</span> <span class="o">=</span>    <span class="n">setrounding</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">RoundDown</span><span class="x">)</span> <span class="n">do</span>        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">reverse_sum</span><span class="x">(</span><span class="n">N</span><span class="x">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="x">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="x">)</span>        <span class="n">sqrt</span><span class="x">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">lower_bound</span><span class="x">)</span>    <span class="k">end</span><span class="n">upper_&pi;</span> <span class="o">=</span>     <span class="n">setrounding</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">RoundUp</span><span class="x">)</span> <span class="n">do</span>        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">reverse_sum</span><span class="x">(</span><span class="n">N</span><span class="x">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span>        <span class="n">sqrt</span><span class="x">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">upper_bound</span><span class="x">)</span>    <span class="k">end</span><span class="x">(</span><span class="n">lower_&pi;</span><span class="x">,</span> <span class="n">upper_&pi;</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>(3.1415926535893144,3.141592653590272)</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">upper_&pi;</span> <span class="o">-</span> <span class="n">lower_&pi;</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>9.57456336436735e-13</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">lower_&pi;</span> <span class="o">&lt;</span> <span class="nb">pi</span> <span class="o">&lt;</span> <span class="n">upper_&pi;</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>true</code></pre></div><p>In principal, we could attain arbitrarily good precision with higher-precision <code class="highlighter-rouge">BigFloat</code>s, but the result is hampered by the slow convergence of the series.</p><h2 id="summing-a-series-using-interval-arithmetic">Summing a series using interval arithmetic</h2><p>We repeat the calculation using <em>interval arithmetic</em>, provided by the <a href="https://github.com/dpsanders/ValidatedNumerics.jl">ValidatedNumerics.jl</a> package.</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">using</span> <span class="n">ValidatedNumerics</span></code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">setdisplay</span><span class="x">(:</span><span class="n">standard</span><span class="x">)</span>  <span class="c"># abbreviated display of intervals</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>6</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">10000</span><span class="n">S</span> <span class="o">=</span> <span class="n">forward_sum</span><span class="x">(</span><span class="n">N</span><span class="x">,</span> <span class="n">Interval</span><span class="x">)</span><span class="n">S</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="x">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="x">)</span> <span class="o">..</span> <span class="mi">1</span><span class="o">/</span><span class="n">N</span>  <span class="c"># interval bound on the remainder of the series</span><span class="n">&pi;_interval</span> <span class="o">=</span> <span class="n">&radic;</span><span class="x">(</span><span class="mi">6</span><span class="n">S</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>[3.14159, 3.1416]</code></pre></div><p>Here we used an abbreviated display for the interval. Let&rsquo;s see the whole thing:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">setdisplay</span><span class="x">(:</span><span class="n">full</span><span class="x">)</span><span class="n">&pi;_interval</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>Interval(3.1415926488148807, 3.141592658365341)</code></pre></div><p>It&rsquo;s diameter (width) is</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">diam</span><span class="x">(</span><span class="n">&pi;_interval</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>9.550460422502738e-9</code></pre></div><p>Thus, the result is correct to approximately 8 decimals.</p><p>In this calculation, we used the fact that arithmetic operations of intervals with numbers automatically promote the numbers to an interval:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">setdisplay</span><span class="x">(:</span><span class="n">full</span><span class="x">)</span>  <span class="c"># full interval display</span><span class="n">Interval</span><span class="x">(</span><span class="mi">0</span><span class="x">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">^</span><span class="mi">2</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>Interval(0.1111111111111111, 0.11111111111111112)</code></pre></div><p>This is an interval containing the true real number $1/9$ (written <code class="highlighter-rouge">1//9</code> in Julia):</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="mi">1</span><span class="o">//</span><span class="mi">9</span> <span class="n">&isin;</span> <span class="nb">convert</span><span class="x">(</span><span class="n">Interval</span><span class="x">{</span><span class="kt">Float64</span><span class="x">},</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">^</span><span class="mi">2</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>true</code></pre></div><p>Finally, we can check that the true value of $\pi$ is indeed inside our interval:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="nb">pi</span> <span class="n">&isin;</span> <span class="n">&pi;_interval</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>true</code></pre></div><h2 id="calculating-an-area">Calculating an area</h2><p>Although the calculation above is simple, the derivation of the series itself is not. In this section, we will use a more natural way to calculate $\pi$, namely that the area of a circle of radius $r$ is $A(r) = \pi r^2$. We will calculate the area of one quadrant of a circle of radius $r=2$, which is equal to $\pi$:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">using</span> <span class="n">Plots</span><span class="x">;</span> <span class="n">gr</span><span class="x">();</span></code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">f</span><span class="x">(</span><span class="n">x</span><span class="x">)</span> <span class="o">=</span> <span class="n">&radic;</span><span class="x">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>f (generic function with 1 method)</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">plot</span><span class="x">(</span><span class="n">f</span><span class="x">,</span> <span class="mi">0</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="n">aspect_ratio</span><span class="o">=</span><span class="x">:</span><span class="n">equal</span><span class="x">,</span> <span class="n">fill</span><span class="o">=</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="x">:</span><span class="n">orange</span><span class="x">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="x">,</span> <span class="n">label</span><span class="o">=</span><span class="s">""</span><span class="x">)</span></code></pre></div>0.5 1.0 1.5 0.0 0.5 1.0 1.5<p>The circle of radius $r=2$ is given by $x^2 + y^2 = 2^2 = 4$, so</p><p>In calculus, we learn that we can approximate integrals using <strong>Riemann sums</strong>. Interval arithmetic allows us to make these Riemann sums <strong>rigorous</strong> in a very simple way, as follows.</p><p>We split up the $x$ axis into intervals, for example of equal width:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="k">function</span><span class="nf"> make_intervals</span><span class="x">(</span><span class="n">N</span><span class="o">=</span><span class="mi">10</span><span class="x">)</span>    <span class="n">xs</span> <span class="o">=</span> <span class="n">linspace</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="x">)</span>    <span class="k">return</span> <span class="x">[</span><span class="n">xs</span><span class="x">[</span><span class="n">i</span><span class="x">]</span><span class="o">..</span><span class="n">xs</span><span class="x">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="x">]</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="x">:</span><span class="n">length</span><span class="x">(</span><span class="n">xs</span><span class="x">)</span><span class="o">-</span><span class="mi">1</span><span class="x">]</span><span class="k">end</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">make_intervals</span><span class="x">()</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>10-element Array{ValidatedNumerics.Interval{Float64},1}: Interval(0.0, 0.2)                                Interval(0.19999999999999998, 0.4)                Interval(0.39999999999999997, 0.6000000000000001) Interval(0.6, 0.8)                                Interval(0.7999999999999999, 1.0)                 Interval(1.0, 1.2000000000000002)                 Interval(1.2, 1.4000000000000001)                 Interval(1.4, 1.6)                                Interval(1.5999999999999999, 1.8)                 Interval(1.7999999999999998, 2.0)                </code></pre></div><p>Given one of those intervals, we evaluate the function of interest:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">II</span> <span class="o">=</span> <span class="n">intervals</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>Interval(0.0, 0.2)</code></pre></div><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">f</span><span class="x">(</span><span class="n">II</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>Interval(1.9899748742132397, 2.0)</code></pre></div><p>The result is an interval that is <strong>guaranteed to contain</strong> the true range of the function $f$ over that interval. So the lower and upper bounds of the intervals may be used as lower and upper bounds of the height of the box in a Riemann integral:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">intervals</span> <span class="o">=</span> <span class="n">make_intervals</span><span class="x">(</span><span class="mi">30</span><span class="x">)</span><span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="x">(</span><span class="n">aspect_ratio</span><span class="o">=</span><span class="x">:</span><span class="n">equal</span><span class="x">)</span><span class="k">for</span> <span class="n">X</span> <span class="k">in</span> <span class="n">intervals</span>    <span class="n">Y</span> <span class="o">=</span> <span class="n">f</span><span class="x">(</span><span class="n">X</span><span class="x">)</span>        <span class="n">plot!</span><span class="x">(</span><span class="n">IntervalBox</span><span class="x">(</span><span class="n">X</span><span class="x">,</span> <span class="n">Interval</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">lo</span><span class="x">)),</span> <span class="n">c</span><span class="o">=</span><span class="x">:</span><span class="n">blue</span><span class="x">,</span> <span class="n">label</span><span class="o">=</span><span class="s">""</span><span class="x">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="x">)</span>    <span class="n">plot!</span><span class="x">(</span><span class="n">IntervalBox</span><span class="x">(</span><span class="n">X</span><span class="x">,</span> <span class="n">Interval</span><span class="x">(</span><span class="n">Y</span><span class="o">.</span><span class="n">lo</span><span class="x">,</span> <span class="n">Y</span><span class="o">.</span><span class="n">hi</span><span class="x">)),</span> <span class="n">c</span><span class="o">=</span><span class="x">:</span><span class="n">red</span><span class="x">,</span> <span class="n">label</span><span class="o">=</span><span class="s">""</span><span class="x">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="x">)</span><span class="k">end</span><span class="n">plot!</span><span class="x">(</span><span class="n">f</span><span class="x">,</span> <span class="mi">0</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span><span class="n">p</span></code></pre></div>0.0 0.5 1.0 1.5 2.0 0.0 0.5 1.0 1.5 2.0 y61<p>Now we just sum up the areas:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">20</span><span class="n">intervals</span> <span class="o">=</span> <span class="n">make_intervals</span><span class="x">(</span><span class="n">N</span><span class="x">)</span><span class="n">width</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">N</span><span class="n">width</span> <span class="o">*</span> <span class="n">sum</span><span class="x">(</span><span class="n">&radic;</span><span class="x">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">X</span><span class="o">^</span><span class="mi">2</span><span class="x">)</span> <span class="k">for</span> <span class="n">X</span> <span class="k">in</span> <span class="n">intervals</span><span class="x">)</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>Interval(3.0284648797549782, 3.2284648797549846)</code></pre></div><p>As we increase the number of sub-intervals, the approximation gets better and better:</p><div class="language-julia highlighter-rouge"><pre class="highlight"><code><span class="n">setdisplay</span><span class="x">(:</span><span class="n">standard</span><span class="x">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="mi">5</span><span class="x">)</span><span class="n">println</span><span class="x">(</span><span class="s">"N </span><span class="se">\t</span><span class="s"> area interval </span><span class="se">\t</span><span class="s"> </span><span class="se">\t</span><span class="s"> diameter"</span><span class="x">)</span><span class="k">for</span> <span class="n">N</span> <span class="k">in</span> <span class="mi">50</span><span class="x">:</span><span class="mi">50</span><span class="x">:</span><span class="mi">1000</span>    <span class="n">intervals</span> <span class="o">=</span> <span class="n">make_intervals</span><span class="x">(</span><span class="n">N</span><span class="x">)</span>    <span class="n">area</span> <span class="o">=</span> <span class="x">(</span><span class="mi">2</span><span class="o">/</span><span class="n">N</span><span class="x">)</span> <span class="o">*</span> <span class="n">sum</span><span class="x">(</span><span class="n">&radic;</span><span class="x">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">X</span><span class="o">^</span><span class="mi">2</span><span class="x">)</span> <span class="k">for</span> <span class="n">X</span> <span class="k">in</span> <span class="n">intervals</span><span class="x">)</span>                <span class="n">println</span><span class="x">(</span><span class="s">"</span><span class="si">$</span><span class="s">N </span><span class="se">\t</span><span class="s"> </span><span class="si">$</span><span class="s">area </span><span class="se">\t</span><span class="s"> </span><span class="si">$</span><span class="s">(diam(area))"</span><span class="x">)</span><span class="k">end</span></code></pre></div><div class="highlighter-rouge"><pre class="highlight"><code>N    area interval           diameter50       [3.0982, 3.1783]        0.0800000000000165100      [3.1204, 3.1605]        0.040000000000032454150      [3.1276, 3.1543]        0.02666666666670814200      [3.1311, 3.1512]        0.02000000000006308250      [3.1332, 3.1493]        0.016000000000075065300      [3.1346, 3.1481]        0.013333333333415354350      [3.1356, 3.1472]        0.011428571428676815400      [3.1364, 3.1465]        0.010000000000123688450      [3.137, 3.146]          0.008888888889027502500      [3.1374, 3.1455]        0.008000000000148333550      [3.1378, 3.1452]        0.007272727272884527600      [3.1381, 3.1449]        0.006666666666829357650      [3.1384, 3.1446]        0.006153846154013376700      [3.1386, 3.1444]        0.0057142857144931725750      [3.1388, 3.1443]        0.005333333333562784800      [3.139, 3.1441]         0.005000000000246363850      [3.1391, 3.1439]        0.004705882353203794900      [3.1393, 3.1438]        0.004444444444719142950      [3.1394, 3.1437]        0.0042105263160761021000     [3.1395, 3.1436]        0.004000000000294435</code></pre></div></div><div class="footer">Julia is a <a href="http://numfocus.org/projects/index.html">NumFocus project</a>. <a href="https://github.com/JuliaLang/julialang.github.com/edit/master/blog/_posts/2017-03-14-piday.md">Edit this page on GitHub.</a></div><!--Flipcause Integration v3.0// Flipcause Integration Instructions:    Install the following code block once in the website Header (after <head> tag) -->  .fc-black_overlay{  display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;  background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;  }  .fc-white_content {  opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;  position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;  }  .fc-main-box{  opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;  }  .fc-widget_close{  opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);  position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;  }  .floating_button{  display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;  position:fixed; z-index:999999; overflow: auto;  }  @keyframes backfadesin {  from { opacity:0; }  to {opacity:.5;}  }  @-moz-keyframes backfadesin {  from { opacity:0; }  to {opacity:.5;}  }  @-webkit-keyframes backfadesin {  from { opacity:0; }  to {opacity:.5;}  }  @-o-keyframes backfadesin {  from { opacity:0; }  to {opacity:.5;}  }  @-ms-keyframes backfadesin {  from { opacity:0; }  to {opacity:.5;}  }  @keyframes fadesin {  0%{ opacity:0; }  50%{ opacity:0; }  75% {opacity: 0; transform: translateY(20px);}  100% {opacity: 1; transform: translateY(0);}  }  @-moz-keyframes fadesin {  0%{ opacity:0; }  50%{ opacity:0; }  75% {opacity: 0; -moz-transform: translateY(20px);}  100% {opacity: 1; -moz-transform: translateY(0);}  }  @-webkit-keyframes fadesin {  0%{ opacity:0; }  50%{ opacity:0; }  75% {opacity: 0; -webkit-transform: translateY(20px);}  100% {opacity: 1; -webkit-transform: translateY(0);}  }  @-o-keyframes fadesin {  0%{ opacity:0; }  50%{ opacity:0; }  75% {opacity: 0; -o-transform: translateY(20px);}  100% {opacity: 1; -o-transform: translateY(0);}  }  @-ms-keyframes fadesin {  0%{ opacity:0; }  50%{ opacity:0; }  75% {opacity: 0; -ms-transform: translateY(20px);}  100% {opacity: 1; -ms-transform: translateY(0);}  }<div id="fc-fade" class="fc-black_overlay"></div><div id="fc-light" class="fc-white_content"><div id="fc-main" class="fc-main-box"><div id="fc-close" class="fc-widget_close"></div></div></div><!--END Flipcause Main Integration Code--><div>Donate Now</div></div></div></div>
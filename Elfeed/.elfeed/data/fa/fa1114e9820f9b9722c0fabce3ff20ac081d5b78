<div class="document">
<p>Docker has matured a lot since it was released nearly 4 years ago. We’ve been watching it closely at Caktus, and have been thrilled by the adoption -- both by the community and by service providers. As a team of Python and Django developers, we’re always searching for best of breed deployment tools. Docker is a clear fit for packaging the underlying code for many projects, including the Python and Django apps we build at Caktus.</p>
<div class="section" id="technical-overview">
<h1>Technical overview</h1>
<p>There are many ways to containerize a Python/Django app, no one of which could be considered “the best.” That being said, I think the following approach provides a good balance of simplicity, configurability, and container size. The specific tools I’ll be using are: <a class="reference external" href="https://www.docker.com/">Docker</a> (of course), <a class="reference external" href="https://alpinelinux.org/">Alpine Linux</a>, and <a class="reference external" href="https://uwsgi-docs.readthedocs.io/">uWSGI</a>.</p>
<p>Alpine Linux is a simple, lightweight Linux distribution based on <a class="reference external" href="https://www.musl-libc.org/">musl libc</a> and <a class="reference external" href="https://busybox.net/about.html">Busybox</a>. Its main claim to fame on the container landscape is that it can create a <a class="reference external" href="https://hub.docker.com/_/alpine/">very small (5MB) Docker image</a>. Typically one’s application will be much larger than that after the code and all dependencies have been included, but the container will still be much smaller than if based on a general-purpose Linux distribution.</p>
<p>There are many WSGI servers available for Python, and we use both Gunicorn and uWSGI at Caktus. A couple of the benefits of uWSGI are that (1) it’s almost entirely configurable through environment variables (which fits well with containers), and (2) it includes <a class="reference external" href="http://uwsgi-docs.readthedocs.io/en/latest/HTTP.html#can-i-use-uwsgi-s-http-capabilities-in-production">native HTTP support</a>, which can circumvent the need for a separate HTTP server like Apache or Nginx, provided static files are hosted on a 3rd-party CDN such as Amazon S3.</p>
</div>
<div class="section" id="the-dockerfile">
<h1>The Dockerfile</h1>
<p>Without further ado, here’s a production-ready <tt class="docutils literal">Dockerfile</tt> you can use as a starting point for your project (it should be added in your top level project directory, or whichever directory contains the Python package(s) provided by your application):</p>
<div class="highlight"><pre><span class="k">FROM</span><span class="s"> python:3.5-alpine</span>

<span class="c"># Copy in your requirements file</span>
<span class="k">ADD</span><span class="s"> requirements.txt /requirements.txt</span>

<span class="c"># OR, if you’re using a directory for your requirements, copy everything (comment out the above and uncomment this if so):</span>
<span class="c"># ADD requirements /requirements</span>

<span class="c"># Install build deps, then run `pip install`, then remove unneeded build deps all in a single step. Correct the path to your production requirements file, if needed.</span>
<span class="k">RUN</span> <span class="nb">set</span> -ex <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apk add --no-cache --virtual .build-deps <span class="se">\</span>
            gcc <span class="se">\</span>
            make <span class="se">\</span>
            libc-dev <span class="se">\</span>
            musl-dev <span class="se">\</span>
            linux-headers <span class="se">\</span>
            pcre-dev <span class="se">\</span>
            postgresql-dev <span class="se">\</span>
    <span class="o">&amp;&amp;</span> pyvenv /venv <span class="se">\</span>
    <span class="o">&amp;&amp;</span> /venv/bin/pip install -U pip <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nv">LIBRARY_PATH</span><span class="o">=</span>/lib:/usr/lib /bin/sh -c <span class="s2">"/venv/bin/pip install -r /requirements.txt"</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> <span class="nv">runDeps</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span> <span class="se">\</span>
            scanelf --needed --nobanner --recursive /venv <span class="se">\</span>
                    <span class="p">|</span> awk <span class="s1">'{ gsub(/,/, "\nso:", $2); print "so:" $2 }'</span> <span class="se">\</span>
                    <span class="p">|</span> sort -u <span class="se">\</span>
                    <span class="p">|</span> xargs -r apk info --installed <span class="se">\</span>
                    <span class="p">|</span> sort -u <span class="se">\</span>
    <span class="k">)</span><span class="s2">"</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apk add --virtual .python-rundeps <span class="nv">$runDeps</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apk del .build-deps

<span class="c"># Copy your application code to the container (make sure you create a .dockerignore file if any large files or directories should be excluded)</span>
<span class="k">RUN</span> mkdir /code/
<span class="k">WORKDIR</span><span class="s"> /code/</span>
<span class="k">ADD</span><span class="s"> . /code/</span>

<span class="c"># uWSGI will listen on this port</span>
<span class="k">EXPOSE</span><span class="s"> 8000</span>

<span class="c"># Add any custom, static environment variables needed by Django or your settings file here:</span>
<span class="k">ENV</span><span class="s"> DJANGO_SETTINGS_MODULE=my_project.settings.deploy</span>

<span class="c"># uWSGI configuration (customize as needed):</span>
<span class="k">ENV</span><span class="s"> UWSGI_VIRTUALENV=/venv UWSGI_WSGI_FILE=my_project/wsgi.py UWSGI_HTTP=:8000 UWSGI_MASTER=1 UWSGI_WORKERS=2 UWSGI_THREADS=8 UWSGI_UID=1000 UWSGI_GID=2000</span>

<span class="c"># Call collectstatic (customize the following line with the minimal environment variables needed for manage.py to run):</span>
<span class="k">RUN</span> <span class="nv">DATABASE_URL</span><span class="o">=</span>none /venv/bin/python manage.py collectstatic --noinput

<span class="c"># Start uWSGI</span>
<span class="k">CMD</span><span class="s"> ["/venv/bin/uwsgi", "--http-auto-chunked", "--http-keepalive"]</span>
</pre></div>

<p>We extend from the Alpine flavor of the official Docker image for Python 3.5, copy the folder containing our requirements files to the container, and then, in a single line, (a) install the OS dependencies needed, (b) <tt class="docutils literal">pip install</tt> the requirements themselves (edit this line to match the location of your requirements file, if needed), (c) scan our virtual environment for any shared libraries linked to by the requirements we installed, and (d) remove the C compiler and any other OS packages no longer needed, except those identified in step (c) (this approach, using <tt class="docutils literal">scanelf</tt>, is borrowed from the underlying <a class="reference external" href="https://github.com/docker-library/python/blob/9f67896dbaf1b86f2446b0ab981aa20f4d336132/3.5/alpine/Dockerfile">3.5-alpine Dockerfile</a>). It’s important to keep this all on one line so that Docker will cache the entire operation as a single layer.</p>
<p>You’ll notice I’ve only included a minimal set of OS dependencies here. If this is an established production app, you’ll most likely need to visit <a class="reference external" href="https://pkgs.alpinelinux.org/packages">https://pkgs.alpinelinux.org/packages</a>, search for the Alpine Linux package names of the OS dependencies you need, including the <tt class="docutils literal"><span class="pre">-dev</span></tt> supplemental packages as needed, and add them to the list above.</p>
<p>Next, we copy our application code to the image, set some default environment variables, and run <tt class="docutils literal">collectstatic</tt>. Be sure to change the values for <tt class="docutils literal">DJANGO_SETTINGS_MODULE</tt> and <tt class="docutils literal">UWSGI_WSGI_FILE</tt> to the correct paths for your application (note that the former requires a Python package path, while the latter requires a file system path). In the event you’re not serving static media directly from the container (e.g., with <a class="reference external" href="http://whitenoise.evans.io/en/stable/">Whitenoise</a>), the <tt class="docutils literal">collectstatic command</tt> can also be removed.</p>
<p>Finally, the <tt class="docutils literal"><span class="pre">--http-auto-chunked</span></tt> and <tt class="docutils literal"><span class="pre">--http-keepalive</span></tt> options to uWSGI are needed in the event the container will be hosted behind an Amazon Elastic Load Balancer (ELB), because Django doesn’t set a valid <tt class="docutils literal"><span class="pre">Content-Length</span></tt> header by default, unless the <tt class="docutils literal">ConditionalGetMiddleware</tt> is enabled. See <a class="reference external" href="http://uwsgi-docs.readthedocs.io/en/latest/HTTP.html#can-i-use-uwsgi-s-http-capabilities-in-production">the note</a> at the end of the uWSGI documentation on HTTP support for further detail.</p>
</div>
<div class="section" id="building-and-testing-the-container">
<h1>Building and testing the container</h1>
<p>Now that you have the essentials in place, you can build your Docker image locally as follows:</p>
<div class="highlight"><pre>docker build -t my-app .
</pre></div>

<p>This will go through all the commands in your Dockerfile, and if successful, store an image with your local Docker server that you could then run:</p>
<div class="highlight"><pre>docker run -e <span class="nv">DATABASE_URL</span><span class="o">=</span>none -t my-app
</pre></div>

<p>This command is merely a smoke test to make sure uWSGI runs, and won’t connect to a database or any other external services.</p>
</div>
<div class="section" id="running-commands-during-container-start-up">
<h1>Running commands during container start-up</h1>
<p>As an optional final step, I recommend creating an <tt class="docutils literal">ENTRYPOINT</tt> script to run commands as needed during container start-up. This will let us accomplish any number of things, such as making sure Postgres is available or running <tt class="docutils literal">migrate</tt> or <tt class="docutils literal">collectstatic</tt> during container start-up. Save the following to a file named <tt class="docutils literal"><span class="pre">docker-entrypoint.sh</span></tt> in the same directory as your <tt class="docutils literal">Dockerfile</tt>:</p>
<div class="highlight"><pre><span class="c">#!/bin/sh</span>
<span class="nb">set</span> -e

<span class="k">until</span> psql <span class="nv">$DATABASE_URL</span> -c <span class="s1">'\l'</span><span class="p">;</span> <span class="k">do</span>
  &gt;<span class="p">&amp;</span><span class="m">2</span> <span class="nb">echo</span> <span class="s2">"Postgres is unavailable - sleeping"</span>
  sleep 1
<span class="k">done</span>

&gt;<span class="p">&amp;</span><span class="m">2</span> <span class="nb">echo</span> <span class="s2">"Postgres is up - continuing"</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"x</span><span class="nv">$DJANGO_MANAGEPY_MIGRATE</span><span class="s2">"</span> <span class="o">=</span> <span class="s1">'xon'</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    /venv/bin/python manage.py migrate --noinput
Fi

<span class="k">if</span> <span class="o">[</span> <span class="s2">"x</span><span class="nv">$DJANGO_MANAGEPY_COLLECTSTATIC</span><span class="s2">"</span> <span class="o">=</span> <span class="s1">'xon'</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    /venv/bin/python manage.py collectstatic --noinput
<span class="k">fi</span>

<span class="nb">exec</span> <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
</pre></div>

<p>Next, add the following line to your <tt class="docutils literal">Dockerfile</tt>, just above the <tt class="docutils literal">CMD</tt> statement:</p>
<div class="highlight"><pre><span class="k">ENTRYPOINT</span><span class="s"> ["/code/docker-entrypoint.sh"]</span>
</pre></div>

<p>This will (a) make sure a database is available (usually only needed when used with Docker Compose), (b) run outstanding migrations, if any, if the <tt class="docutils literal">DJANGO_MANAGEPY_MIGRATE</tt> is set to <tt class="docutils literal">on</tt> in your environment, and (c) run <tt class="docutils literal">collectstatic</tt> if <tt class="docutils literal">DJANGO_MANAGEPY_COLLECTSTATIC</tt> is set to <tt class="docutils literal">on</tt> in your environment. Even if you add this entrypoint script as-is, you could still choose to run <tt class="docutils literal">migrate</tt> or <tt class="docutils literal">collectstatic</tt> in separate steps in your deployment before releasing the new container. The only reason you might not want to do this is if your application is highly sensitive to container start-up time, or if you want to avoid any database calls as the container starts up (e.g., for local testing). If you do rely on these commands being run during container start-up, be sure to set the relevant variables in your container’s environment.</p>
</div>
<div class="section" id="creating-a-production-like-environment-locally-with-docker-compose">
<h1>Creating a production-like environment locally with Docker Compose</h1>
<p>To run a complete copy of production services locally, you can use <a class="reference external" href="https://docs.docker.com/compose/">Docker Compose</a>. The following <tt class="docutils literal"><span class="pre">docker-compose.yml</span></tt> will create a barebones, ephemeral, AWS-like container environment with Postgres and Redis for testing your production environment locally.</p>
<p><em>This is intended for local testing of your production environment only, and will not save data from stateful services like Postgres upon container shutdown.</em></p>
<div class="highlight"><pre><span class="l-Scalar-Plain">version</span><span class="p-Indicator">:</span> <span class="s">'2'</span>

<span class="l-Scalar-Plain">services</span><span class="p-Indicator">:</span>
  <span class="l-Scalar-Plain">db</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">environment</span><span class="p-Indicator">:</span>
      <span class="l-Scalar-Plain">POSTGRES_DB</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">app_db</span>
      <span class="l-Scalar-Plain">POSTGRES_USER</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">app_user</span>
      <span class="l-Scalar-Plain">POSTGRES_PASSWORD</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">changeme</span>
    <span class="l-Scalar-Plain">restart</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">always</span>
    <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">postgres:9.6</span>
    <span class="l-Scalar-Plain">expose</span><span class="p-Indicator">:</span>
      <span class="p-Indicator">-</span> <span class="s">"5432"</span>
  <span class="l-Scalar-Plain">redis</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">restart</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">always</span>
    <span class="l-Scalar-Plain">image</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">redis:3.0</span>
    <span class="l-Scalar-Plain">expose</span><span class="p-Indicator">:</span>
      <span class="p-Indicator">-</span> <span class="s">"6379"</span>
  <span class="l-Scalar-Plain">app</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">environment</span><span class="p-Indicator">:</span>
      <span class="l-Scalar-Plain">DATABASE_URL</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">postgres://app_user:changeme@db/app_db</span>
      <span class="l-Scalar-Plain">REDIS_URL</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">redis://redis</span>
      <span class="l-Scalar-Plain">DJANGO_MANAGEPY_MIGRATE</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">on</span>
    <span class="l-Scalar-Plain">build</span><span class="p-Indicator">:</span>
      <span class="l-Scalar-Plain">context</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">.</span>
      <span class="l-Scalar-Plain">dockerfile</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">./Dockerfile</span>
    <span class="l-Scalar-Plain">links</span><span class="p-Indicator">:</span>
      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">db:db</span>
      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">redis:redis</span>
    <span class="l-Scalar-Plain">ports</span><span class="p-Indicator">:</span>
      <span class="p-Indicator">-</span> <span class="s">"8000:8000"</span>
    <span class="l-Scalar-Plain">depends_on</span><span class="p-Indicator">:</span>
      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">db</span>
      <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">redis</span>
</pre></div>

<p>Copy this into a file named <tt class="docutils literal"><span class="pre">docker-compose.yml</span></tt> in the same directory as your <tt class="docutils literal">Dockerfile</tt>, and then run:</p>
<div class="highlight"><pre>docker-compose up --build -d
</pre></div>

<p>This downloads (or builds) and starts the three containers listed above. You can view output from the containers by running:</p>
<div class="highlight"><pre>docker-compose logs
</pre></div>

<p>If all services launched successfully, you should now be able to access your application at <a class="reference external" href="http://localhost:8000/">http://localhost:8000/</a> in a web browser.</p>
</div>
<div class="section" id="extra-blocking-invalid-http-host-header-errors-with-uwsgi">
<h1>Extra: Blocking <tt class="docutils literal">Invalid HTTP_HOST header</tt> errors with uWSGI</h1>
<p>To avoid Django’s <tt class="docutils literal">Invalid HTTP_HOST header</tt> errors (and prevent any such spurious requests from taking up any more CPU cycles than absolutely necessary), you can also configure uWSGI to return an <tt class="docutils literal">HTTP 400</tt> response immediately without ever invoking your application code. This can be accomplished by adding a command line option to uWSGI in your <tt class="docutils literal">Dockerfile</tt> script, e.g., <tt class="docutils literal"><span class="pre">--route-host=’^(?!www.myapp.com$)</span> break:400'</tt> (note, the single quotes are required here, to prevent the shell from attempting to interpret the regular expression). If preferred (for example, in the event you use a different domain for staging and production), you can accomplish the same end by setting an environment variable via your hosting platform: <tt class="docutils literal"><span class="pre">UWSGI_ROUTE_HOST=‘^(?!www.myapp.com$)</span> break:400'</tt>.</p>
<p>That concludes this high-level introduction to containerizing your Python/Django app for hosting on AWS Elastic Beanstalk (EB), Elastic Container Service (ECS), or elsewhere. Each application and Dockerfile will be slightly different, but I hope this provides a good starting point for your containers. Shameless plug: If you’re looking for a simple (and at least temporarily free) way to test your Docker containers on AWS using an Elastic Beanstalk Multicontainer Docker environment or the Elastic Container Service, checkout <a class="reference external" href="https://github.com/tobiasmcnulty/aws-container-basics">AWS Container Basics</a> (more on this soon). Good luck!</p>
</div>
</div>
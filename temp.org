* 列表
  |数据结构| -> 指针/内存
  
  
  Lisp 程序开发通常呼应着开发 Lisp 语言自身
  列表  ->  多种数据结构

** major-core 数据结构
当你赋一个值给变量或将这个值存在数据结构中，其实被储存的是指向这个值的指针。当你要取得变量的值，或是存在数据结构中的内容时， Lisp 返回指向这个值的指针。
东西放在任何地方。除非你声明你不愿这么做，不然你能够在任何的数据结构，存放任何类型的对象，包括结构本身
。在 Common Lisp 里，无论何时你使用一个数字来参照一个数据结构中的元素时，都是从 0 开始编号的。
这不是个好名字，因为非正规列表的 Cons 对象通常不是用来表示列表： (a . b) 只是一个有两部分的数据结构
。当程序进化时，你可以在代码的关键部分使用破坏性函数以及/或别种
*** minor-core 指针
两部分的对象，称之为 Cons 对象。概念上来说，一个 Cons 是一对指针；第一个是 car ，第二个是 cdr 。
Cons 所组成，见图 3.1。这种表达 Cons 的方式叫做箱子表示法 (box notation)，因为每一个 Cons 是用一个箱子表示，内含一个 car 和 cdr 的指针。当我们调用 car 与 cdr 时
，当我们调用 car 与 cdr 时，我们得到指针指向的地方：

> (car x)
A
> (cdr x)
NIL
在一个有多个元素的列表中， car 指针让你取得元素，而 cdr 让你取得列表内其余的东西。
当这种情况发生时，它的结构如图 3.3 所示；第二个 Cons 的 car 指针也指向一个列表：

> (car (cdr z))
(B C)

每一次你调用 cons 时， Lisp 会配置一块新的内存给两个指针。
一个理解 Lisp 的秘密之一是意识到变量是有值的，就像列表有元素一样。如同 Cons 对象有指针指向他们的元素，变量有指针指向他们的值。

你可能在别的语言中使用过显式指针 (explicitly pointer)。在 Lisp，你永远不用这么做，因为语言帮你处理好指针了。

当我们把 x 的值赋给 y 时，究竟发生什么事呢？内存中与 x 有关的位置并没有包含这个列表，而是一个指针指向它。当我们给 y 赋一个相同的值时， Lisp 复制的是指针，而不是列表
电脑内部里， Cons 对象倾向于用指针表示，所以走访一个列表意味着走访一系列的指针，而不是简单地像数组一样增加索引值。但这两个所花的代价与配置及回收 Cons 核 (cons cells)比起来小多了。

一开始我们调用 list ， list 调用 cons ，在堆上配置了一个新的 Cons 对象。在这个情况我们创出三个 Cons 对象。之后当我们把 lst 设为 nil ，我们没有任何方法可以再存取 lst ，列表 (a b c) 。 [5]

因为我们没有任何方法再存取列表，它也有可能是不存在的。我们不再有任何方式可以存取的对象叫做垃圾。系统可以安全地重新使用这三个 Cons 核。

这种管理內存的方法，给程序员带来极大的便利性。你不用显式地配置 (allocate)或释放 (dellocate)內存。这也表示了你不需要处理因为这么做而可能产生的臭虫。內存泄漏 (Memory leaks)以及迷途指针 (dangling pointer)在 Lisp 中根本不可能发生。
*** minor-core 内存
 每一次你调用 cons 时， Lisp 会配置一块新的内存给两个指针。所以如果我们用同样的参数调用 cons 两次，我们得到两个数值看起来一样，但实际上是两个不同的对象：

> (eql (cons 'a nil) (cons 'a nil))
NIL

举例来说，因为一个小整数所需的内存空间，少于一个指针所需的空间，一个 Lisp 实现可能会直接处理这个小整数，而不是用指针来处理。但基本要点是，程序员预设可以把任何东西放在任何地方

自动内存管理(Automatic memory management)是 Lisp 最有价值的特色之一。 Lisp 系统维护着一段內存称之为堆(Heap)。系统持续追踪堆当中没有使用的内存，把这些内存发放给新产生的对象

举例来说，函数 cons ，返回一个新配置的 Cons 对象。从堆中配置内存有时候通称为 consing 。

所以系统必须周期性地通过搜索堆 (heap)，寻找不需要再使用的内存。

*** minor-core cons
1. cons 真正所做的事情是，把两个对象结合成一个有两部分的对象，称之为 Cons 对象。
2. 概念上来说，一个 Cons 是一对指针；第一个是 car ，第二个是 cdr
3. Cons 对象提供了一个方便的表示法，来表示任何类型的对象。


** 构造
** 等式
** why no pointers
** 建立列表
** 示例:压缩
** 存取
** 映射函数
** 树
** 理解递归
** 集合
** 序列
** 栈
** 点状列表
** 关联列表
** 示例:最短路径
** 垃圾回收
** 总结
